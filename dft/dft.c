
/*
********************************************************************************
*                                                                              *
* Copyright (c) 2019 Davide Asnaghi                                            *
*                                                                              *
* Permission is hereby granted, free of charge, to any person obtaining a      *
* copy of this software and associated documentation files (the "Software"),   *
* to deal in the Software without restriction, including without limitation    *
* the rights to use, copy, modify, merge, publish, distribute, sublicense,     *
* and/or sell copies of the Software, and to permit persons to whom the        *
* Software is furnished to do so, subject to the following conditions:         *
*                                                                              *
* The above copyright notice and this permission notice shall be included      *
* in all copies or substantial portions of the Software.                       *
*                                                                              *
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR   *
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,     *
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL      *
* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER   *
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING      *
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER          *
* DEALINGS IN THE SOFTWARE.                                                    *
*                                                                              *
********************************************************************************
*/

#include <stdint.h>
#include <math.h>
#include <stdlib.h>

/*******************************************************************************
 BASIC DISCRETE FOURIER TRANSFORM O(N^2)
 *******************************************************************************/

#define REAL 	0
#define IMM		1
#define PWR		2
#define TWO_PI	3.1415*2

float ** dft_basic (float x[], uint32_t N){

	float ** transform =  (float **) malloc(sizeof(float*) * 3);
	transform[REAL] = (float *) calloc(sizeof(float), N);
	transform[IMM] = (float *) calloc(sizeof(float), N);

	for(int k=0; k<N; k++){
		// compute real and imaginary parts based on the pure equation
		int n;
		for(n=0; n<N; n++) transform[REAL][k] += x[n]*cos(TWO_PI*k/N*n);
		for(n=0; n<N; n++) transform[IMM][k] -= x[n]*sin(TWO_PI*k/N*n);

		// NOTE: sin() and cos() are implementation and FPU dependent
	}
	
	return transform;
}

/*******************************************************************************
 OPTIMIZED DISCRETE FOURIER TRANSFORM O(N^2)
 *******************************************************************************/

float ** dft_optimized (float x[], uint32_t N){

	float ** transform =  (float **) malloc(sizeof(float*) * 3);
	transform[REAL] = (float *) calloc(sizeof(float), N);
	transform[IMM] = (float *) calloc(sizeof(float), N);

	for(int k=0; k<N; k++){
		// compute multiplication factor at each k
		float c = TWO_PI*k/N;
		// compute real and imaginary parts
		int n;
		for(int n=0; n<N; n++) transform[REAL][k] += x[n]*cos(c*n);
		for(int n=0; n<N; n++) transform[IMM][k] -= x[n]*sin(c*n);

		// NOTE: sin() and cos() are implementation and FPU dependent
	}
	
	return transform;
}

/*******************************************************************************
 LOOK-UP DISCRETE FOURIER TRANSFORM O(N^2)
 *******************************************************************************/

// Include the N-lookup table generated by "lookup.c"
#include "lookup.h"

float ** dft_lookup (float x[], uint32_t N){

	float ** tfm =  (float **) malloc(sizeof(float*) * 3);
	tfm[REAL] = (float *) calloc(sizeof(float), N);
	tfm[IMM] = (float *) calloc(sizeof(float), N);

    int to_sin = 3*N/4; // index offset for sin
    int a, b;

	for(int k=0; k<N; k++){
		
		tfm[REAL][k] = 0; tfm[IMM][k] = 0;
        a = 0; b = to_sin;

        // compute real and imaginary parts from the lookup
        int n;
        for (n=0; n<N; ++n){
            tfm[REAL][k] += x[n] * LOOKUP[a%N];
            tfm[IMM][k] -= x[n] * LOOKUP[b%N];
            a += k; b += k;
        }
	}
	
	return tfm;
}

/*******************************************************************************
 DRIVER CODE
 *******************************************************************************/

#include <stdio.h>
#include <math.h>
#include <time.h>

#define TIMING 0
#define N_TRIAL 100

double timed(float** fn(float*, uint32_t), float arr[], uint32_t len){
	
	clock_t t; 
	double time_taken=0;
	uint8_t n;

	for (n=0; n<N_TRIAL; n++){
		t = clock(); 
		fn(arr, len);
		t = clock() - t; 
		time_taken += ((double)t)/CLOCKS_PER_SEC; // in seconds `
	}
	
	return (time_taken/N_TRIAL)*1000;
}

void plot_power(float** tfm, uint32_t len){
	uint32_t i;
	for (i=0; i<len/2-1; i++){
		 printf("%.3f\n", tfm[REAL][i]*tfm[REAL][i] + tfm[IMM][i]*tfm[IMM][i]);
	}
}

int main(int argc, char const *argv[])
{

	// 1024 samples in the input signal, use lookup.c to generate a different N
	const uint32_t len = 1024;	
	float signal [len];

	// synthetic signal with 3 main frequency components
	int t;
	for (t=0; t<len; t++)
		signal[t] = sin(100*(TWO_PI*(float)t/len)) + \
					sin(200*(TWO_PI*(float)t/len)) + \
					2*cos(300*(TWO_PI*(float)t/len));

	// define to time the function, leave unset for power spectrum stdout
	if (TIMING){
		printf("[DFT LOOKUP: %.2f ms, N = %d]\n", timed(dft_lookup, signal, len), len);
		printf("[DFT OPTIMIZED: %.2f ms, N = %d]\n", timed(dft_optimized, signal, len), len);
		printf("[DFT BASIC: %.2f ms, N = %d]\n", timed(dft_basic, signal, len), len);
	} else {
		float ** transform = dft_lookup(signal, len);
		plot_power(transform, len);
	}

	return 0;
}